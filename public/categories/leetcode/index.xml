<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 编程日记</title>
    <link>/categories/leetcode/</link>
    <description>Recent content in LeetCode on 编程日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2019-{year} jimyag. All Rights Reserved. </copyright>
    <lastBuildDate>Sun, 09 Jan 2022 00:21:39 +0000</lastBuildDate><atom:link href="/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode-1629-按键持续时间最长的键</title>
      <link>/posts/81eca2cd/</link>
      <pubDate>Sun, 09 Jan 2022 00:21:39 +0000</pubDate>
      
      <guid>/posts/81eca2cd/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。&lt;/p&gt;
&lt;p&gt;给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。&lt;/p&gt;
&lt;p&gt;测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。&lt;/p&gt;
&lt;p&gt;注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。&lt;/p&gt;
&lt;p&gt;请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-第69场双周赛</title>
      <link>/posts/3087638f/</link>
      <pubDate>Sat, 08 Jan 2022 23:52:25 +0000</pubDate>
      
      <guid>/posts/3087638f/</guid>
      <description>&lt;p&gt;双周赛太离谱了，签到完就溜。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-89-格雷编码</title>
      <link>/posts/b9635535/</link>
      <pubDate>Sat, 08 Jan 2022 17:52:15 +0000</pubDate>
      
      <guid>/posts/b9635535/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;n 位格雷码序列 是一个由 2^n 个整数组成的序列，其中：
每个整数都在范围 [0, 2^n - 1] 内（含 0 和 2^n - 1）
第一个整数是 0
一个整数在序列中出现 不超过一次
每对 相邻 整数的二进制表示 恰好一位不同 ，且第一个 和 最后一个 整数的二进制表示 恰好一位不同
给你一个整数 n ，返回任一有效的 n 位格雷码序列 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1614-括号的最大嵌套深度</title>
      <link>/posts/965e3905/</link>
      <pubDate>Fri, 07 Jan 2022 00:11:54 +0000</pubDate>
      
      <guid>/posts/965e3905/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：&lt;/p&gt;
&lt;p&gt;字符串是一个空字符串 &amp;ldquo;&amp;quot;，或者是一个不为 &amp;ldquo;(&amp;rdquo; 或 &amp;ldquo;)&amp;rdquo; 的单字符。
字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：&lt;/p&gt;
&lt;p&gt;depth(&amp;rdquo;&amp;quot;) = 0
depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 &amp;ldquo;(&amp;rdquo; 或者 &amp;ldquo;)&amp;rdquo;
depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
depth(&amp;quot;(&amp;quot; + A + &amp;ldquo;)&amp;rdquo;) = 1 + depth(A)，其中 A 是一个 有效括号字符串
例如：&amp;quot;&amp;quot;、&amp;quot;()()&amp;quot;、&amp;quot;()(()())&amp;quot; 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 &amp;ldquo;)(&amp;rdquo; 、&amp;quot;(()&amp;quot; 都不是 有效括号字符串 。&lt;/p&gt;
&lt;p&gt;给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-71-简化路径</title>
      <link>/posts/30245f9e/</link>
      <pubDate>Thu, 06 Jan 2022 22:08:14 +0000</pubDate>
      
      <guid>/posts/30245f9e/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &amp;lsquo;/&amp;rsquo; 开头），请你将其转化为更加简洁的规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&amp;rsquo;//&amp;rsquo;）都被视为单个斜杠 &amp;lsquo;/&amp;rsquo; 。 对于此问题，任何其他格式的点（例如，&amp;rsquo;&amp;hellip;&amp;rsquo;）均被视为文件/目录名称。&lt;/p&gt;
&lt;p&gt;请注意，返回的 规范路径 必须遵循下述格式：&lt;/p&gt;
&lt;p&gt;始终以斜杠 &amp;lsquo;/&amp;rsquo; 开头。
两个目录名之间必须只有一个斜杠 &amp;lsquo;/&amp;rsquo; 。
最后一个目录名（如果存在）不能 以 &amp;lsquo;/&amp;rsquo; 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &amp;lsquo;.&amp;rsquo; 或 &amp;lsquo;..&amp;rsquo;）。
返回简化后得到的 规范路径 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1576-替换所有的问号</title>
      <link>/posts/68d43a4d/</link>
      <pubDate>Wed, 05 Jan 2022 22:16:03 +0000</pubDate>
      
      <guid>/posts/68d43a4d/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个仅包含小写英文字母和 &amp;lsquo;?&amp;rsquo; 字符的字符串 s，请你将所有的 &amp;lsquo;?&amp;rsquo; 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。&lt;/p&gt;
&lt;p&gt;注意：你 不能 修改非 &lt;code&gt;?&lt;/code&gt; 字符。&lt;/p&gt;
&lt;p&gt;题目测试用例保证 除 &lt;code&gt;?&lt;/code&gt; 字符 之外，不存在连续重复的字符。&lt;/p&gt;
&lt;p&gt;在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-913-猫和老鼠</title>
      <link>/posts/e1f1048f/</link>
      <pubDate>Tue, 04 Jan 2022 21:15:17 +0000</pubDate>
      
      <guid>/posts/e1f1048f/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。&lt;/p&gt;
&lt;p&gt;图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。&lt;/p&gt;
&lt;p&gt;老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。&lt;/p&gt;
&lt;p&gt;在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。&lt;/p&gt;
&lt;p&gt;此外，猫无法移动到洞中（节点 0）。&lt;/p&gt;
&lt;p&gt;然后，游戏在出现以下三种情形之一时结束：&lt;/p&gt;
&lt;p&gt;如果猫和老鼠出现在同一个节点，猫获胜。
如果老鼠到达洞中，老鼠获胜。
如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p&gt;
&lt;p&gt;如果老鼠获胜，则返回 1；
如果猫获胜，则返回 2；
如果平局，则返回 0 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1185-一周中的第几天</title>
      <link>/posts/95bcecc9/</link>
      <pubDate>Mon, 03 Jan 2022 12:14:06 +0000</pubDate>
      
      <guid>/posts/95bcecc9/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。&lt;/p&gt;
&lt;p&gt;输入为三个整数：day、month 和 year，分别表示日、月、年。&lt;/p&gt;
&lt;p&gt;您返回的结果必须是这几个值中的一个 {&amp;ldquo;Sunday&amp;rdquo;, &amp;ldquo;Monday&amp;rdquo;, &amp;ldquo;Tuesday&amp;rdquo;, &amp;ldquo;Wednesday&amp;rdquo;, &amp;ldquo;Thursday&amp;rdquo;, &amp;ldquo;Friday&amp;rdquo;, &amp;ldquo;Saturday&amp;rdquo;}。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-第274场周赛</title>
      <link>/posts/43ef6653/</link>
      <pubDate>Sun, 02 Jan 2022 12:21:54 +0000</pubDate>
      
      <guid>/posts/43ef6653/</guid>
      <description>&lt;p&gt;第一次参加LeetCode的周赛，记录一下自己AC的三道简单题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-390-消除游戏</title>
      <link>/posts/297384ed/</link>
      <pubDate>Sun, 02 Jan 2022 01:23:36 +0000</pubDate>
      
      <guid>/posts/297384ed/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定一个从1 到 n 排序的整数列表。
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
返回长度为 n 的列表中，最后剩下的数字。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-2022-将一维数组转变成二维数组</title>
      <link>/posts/9806fff7/</link>
      <pubDate>Sat, 01 Jan 2022 15:33:21 +0000</pubDate>
      
      <guid>/posts/9806fff7/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。&lt;/p&gt;
&lt;p&gt;original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。&lt;/p&gt;
&lt;p&gt;请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-507-完美数</title>
      <link>/posts/9c98d12/</link>
      <pubDate>Fri, 31 Dec 2021 08:16:09 +0000</pubDate>
      
      <guid>/posts/9c98d12/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。&lt;/p&gt;
&lt;p&gt;给定一个 整数 n， 如果是完美数，返回 true，否则返回 false&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-846-一手顺子</title>
      <link>/posts/111b38ee/</link>
      <pubDate>Thu, 30 Dec 2021 10:06:01 +0000</pubDate>
      
      <guid>/posts/111b38ee/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1995-统计特殊四元组</title>
      <link>/posts/ace15a6d/</link>
      <pubDate>Wed, 29 Dec 2021 10:51:23 +0000</pubDate>
      
      <guid>/posts/ace15a6d/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：&lt;/p&gt;
&lt;p&gt;nums[a] + nums[b] + nums[c] == nums[d] ，且
a &amp;lt; b &amp;lt; c &amp;lt; d&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-472-连接词</title>
      <link>/posts/a9eb621/</link>
      <pubDate>Tue, 28 Dec 2021 09:29:23 +0000</pubDate>
      
      <guid>/posts/a9eb621/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。&lt;/p&gt;
&lt;p&gt;连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-825-适龄的朋友</title>
      <link>/posts/69e04ce/</link>
      <pubDate>Mon, 27 Dec 2021 09:42:27 +0000</pubDate>
      
      <guid>/posts/69e04ce/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。&lt;/p&gt;
&lt;p&gt;如果下述任意一个条件为真，那么用户 x 将不会向用户 y&lt;code&gt;（x != y）&lt;/code&gt;发送好友请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;lt;= 0.5 * age[x] + 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;gt; age[x]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;gt; 100 &amp;amp;&amp;amp; age[x] &amp;lt; 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;否则，x 将会向 y 发送一条好友请求。&lt;/p&gt;
&lt;p&gt;注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。&lt;/p&gt;
&lt;p&gt;返回在该社交媒体网站上产生的好友请求总数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1078-Bigram-分词</title>
      <link>/posts/e0d1a0/</link>
      <pubDate>Sun, 26 Dec 2021 23:15:20 +0000</pubDate>
      
      <guid>/posts/e0d1a0/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 &amp;ldquo;first second third&amp;rdquo; 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。&lt;/p&gt;
&lt;p&gt;对于每种这样的情况，将第三个词 &amp;ldquo;third&amp;rdquo; 添加到答案中，并返回答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1609-奇偶树</title>
      <link>/posts/1c05b892/</link>
      <pubDate>Sat, 25 Dec 2021 19:47:39 +0000</pubDate>
      
      <guid>/posts/1c05b892/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：&lt;/p&gt;
&lt;p&gt;二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1705-吃苹果的最大数目</title>
      <link>/posts/48cf338b/</link>
      <pubDate>Fri, 24 Dec 2021 11:07:03 +0000</pubDate>
      
      <guid>/posts/48cf338b/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。&lt;/p&gt;
&lt;p&gt;你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。&lt;/p&gt;
&lt;p&gt;给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1044-最长重复子串</title>
      <link>/posts/8669609e/</link>
      <pubDate>Thu, 23 Dec 2021 22:47:24 +0000</pubDate>
      
      <guid>/posts/8669609e/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。&lt;/p&gt;
&lt;p&gt;返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 &amp;quot;&amp;quot; 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-686-重复叠加字符串匹配</title>
      <link>/posts/cb644e85/</link>
      <pubDate>Wed, 22 Dec 2021 09:21:49 +0000</pubDate>
      
      <guid>/posts/cb644e85/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&lt;/p&gt;
&lt;p&gt;注意：字符串 &amp;ldquo;abc&amp;rdquo; 重复叠加 0 次是 &amp;ldquo;&amp;quot;，重复叠加 1 次是 &amp;ldquo;abc&amp;rdquo;，重复叠加 2 次是 &amp;ldquo;abcabc&amp;rdquo;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1154-一年中的第几天</title>
      <link>/posts/bd5751e9/</link>
      <pubDate>Tue, 21 Dec 2021 08:58:18 +0000</pubDate>
      
      <guid>/posts/bd5751e9/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。&lt;/p&gt;
&lt;p&gt;通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-475-供暖器</title>
      <link>/posts/e63dcfe3/</link>
      <pubDate>Mon, 20 Dec 2021 09:31:58 +0000</pubDate>
      
      <guid>/posts/e63dcfe3/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。&lt;/p&gt;
&lt;p&gt;在加热器的加热半径范围内的每个房屋都可以获得供暖。&lt;/p&gt;
&lt;p&gt;现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。&lt;/p&gt;
&lt;p&gt;说明：所有供暖器都遵循你的半径标准，加热的半径也一样。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-997-找到小镇的法官</title>
      <link>/posts/e18d9e0d/</link>
      <pubDate>Sun, 19 Dec 2021 22:14:28 +0000</pubDate>
      
      <guid>/posts/e18d9e0d/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。&lt;/p&gt;
&lt;p&gt;如果小镇的法官真的存在，那么：&lt;/p&gt;
&lt;p&gt;小镇的法官不相信任何人。
每个人（除了小镇法官外）都信任小镇的法官。
只有一个人同时满足条件 1 和条件 2 。
给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。&lt;/p&gt;
&lt;p&gt;如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-419-甲板上的战舰</title>
      <link>/posts/aa19f9bb/</link>
      <pubDate>Sat, 18 Dec 2021 15:48:25 +0000</pubDate>
      
      <guid>/posts/aa19f9bb/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 &amp;lsquo;X&amp;rsquo; 或者是一个空位 &amp;lsquo;.&amp;rsquo; ，返回在甲板 board 上放置的 战舰 的数量。&lt;/p&gt;
&lt;p&gt;战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1518-换酒问题</title>
      <link>/posts/656c6fd2/</link>
      <pubDate>Fri, 17 Dec 2021 10:47:30 +0000</pubDate>
      
      <guid>/posts/656c6fd2/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。&lt;/p&gt;
&lt;p&gt;如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。&lt;/p&gt;
&lt;p&gt;请你计算 最多 能喝到多少瓶酒。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1610-可见点的最大数目</title>
      <link>/posts/5a04344/</link>
      <pubDate>Thu, 16 Dec 2021 22:01:05 +0000</pubDate>
      
      <guid>/posts/5a04344/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。&lt;/p&gt;
&lt;p&gt;最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。&lt;/p&gt;
&lt;p&gt;对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。&lt;/p&gt;
&lt;p&gt;同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。&lt;/p&gt;
&lt;p&gt;返回你能看到的点的最大数目。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-851-喧闹和富有</title>
      <link>/posts/3f29dc95/</link>
      <pubDate>Wed, 15 Dec 2021 20:53:25 +0000</pubDate>
      
      <guid>/posts/3f29dc95/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。&lt;/p&gt;
&lt;p&gt;给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。&lt;/p&gt;
&lt;p&gt;现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-630-课程表3</title>
      <link>/posts/52f591e7/</link>
      <pubDate>Tue, 14 Dec 2021 09:04:00 +0000</pubDate>
      
      <guid>/posts/52f591e7/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。&lt;/p&gt;
&lt;p&gt;你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。&lt;/p&gt;
&lt;p&gt;返回你最多可以修读的课程数目。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-807-保持城市天际线</title>
      <link>/posts/9457eaea/</link>
      <pubDate>Mon, 13 Dec 2021 17:59:13 +0000</pubDate>
      
      <guid>/posts/9457eaea/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。&lt;/p&gt;
&lt;p&gt;城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。&lt;/p&gt;
&lt;p&gt;我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。&lt;/p&gt;
&lt;p&gt;在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-709-转换成小写字母</title>
      <link>/posts/1af266db/</link>
      <pubDate>Sun, 12 Dec 2021 07:43:09 +0000</pubDate>
      
      <guid>/posts/1af266db/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目：&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-911-在线选举</title>
      <link>/posts/acd85fa1/</link>
      <pubDate>Sat, 11 Dec 2021 16:56:15 +0000</pubDate>
      
      <guid>/posts/acd85fa1/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。&lt;/p&gt;
&lt;p&gt;对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。&lt;/p&gt;
&lt;p&gt;在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。&lt;/p&gt;
&lt;p&gt;实现 TopVotedCandidate 类：&lt;/p&gt;
&lt;p&gt;TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
