<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>中等 on 编程日记</title>
    <link>/tags/%E4%B8%AD%E7%AD%89/</link>
    <description>Recent content in 中等 on 编程日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2019-{year} jimyag. All Rights Reserved. </copyright>
    <lastBuildDate>Sat, 08 Jan 2022 17:52:15 +0000</lastBuildDate><atom:link href="/tags/%E4%B8%AD%E7%AD%89/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode-89-格雷编码</title>
      <link>/posts/b9635535/</link>
      <pubDate>Sat, 08 Jan 2022 17:52:15 +0000</pubDate>
      
      <guid>/posts/b9635535/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;n 位格雷码序列 是一个由 2^n 个整数组成的序列，其中：
每个整数都在范围 [0, 2^n - 1] 内（含 0 和 2^n - 1）
第一个整数是 0
一个整数在序列中出现 不超过一次
每对 相邻 整数的二进制表示 恰好一位不同 ，且第一个 和 最后一个 整数的二进制表示 恰好一位不同
给你一个整数 n ，返回任一有效的 n 位格雷码序列 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-71-简化路径</title>
      <link>/posts/30245f9e/</link>
      <pubDate>Thu, 06 Jan 2022 22:08:14 +0000</pubDate>
      
      <guid>/posts/30245f9e/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &amp;lsquo;/&amp;rsquo; 开头），请你将其转化为更加简洁的规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&amp;rsquo;//&amp;rsquo;）都被视为单个斜杠 &amp;lsquo;/&amp;rsquo; 。 对于此问题，任何其他格式的点（例如，&amp;rsquo;&amp;hellip;&amp;rsquo;）均被视为文件/目录名称。&lt;/p&gt;
&lt;p&gt;请注意，返回的 规范路径 必须遵循下述格式：&lt;/p&gt;
&lt;p&gt;始终以斜杠 &amp;lsquo;/&amp;rsquo; 开头。
两个目录名之间必须只有一个斜杠 &amp;lsquo;/&amp;rsquo; 。
最后一个目录名（如果存在）不能 以 &amp;lsquo;/&amp;rsquo; 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &amp;lsquo;.&amp;rsquo; 或 &amp;lsquo;..&amp;rsquo;）。
返回简化后得到的 规范路径 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-第274场周赛</title>
      <link>/posts/43ef6653/</link>
      <pubDate>Sun, 02 Jan 2022 12:21:54 +0000</pubDate>
      
      <guid>/posts/43ef6653/</guid>
      <description>&lt;p&gt;第一次参加LeetCode的周赛，记录一下自己AC的三道简单题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-390-消除游戏</title>
      <link>/posts/297384ed/</link>
      <pubDate>Sun, 02 Jan 2022 01:23:36 +0000</pubDate>
      
      <guid>/posts/297384ed/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定一个从1 到 n 排序的整数列表。
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
返回长度为 n 的列表中，最后剩下的数字。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-846-一手顺子</title>
      <link>/posts/111b38ee/</link>
      <pubDate>Thu, 30 Dec 2021 10:06:01 +0000</pubDate>
      
      <guid>/posts/111b38ee/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-825-适龄的朋友</title>
      <link>/posts/69e04ce/</link>
      <pubDate>Mon, 27 Dec 2021 09:42:27 +0000</pubDate>
      
      <guid>/posts/69e04ce/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。&lt;/p&gt;
&lt;p&gt;如果下述任意一个条件为真，那么用户 x 将不会向用户 y&lt;code&gt;（x != y）&lt;/code&gt;发送好友请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;lt;= 0.5 * age[x] + 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;gt; age[x]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;age[y] &amp;gt; 100 &amp;amp;&amp;amp; age[x] &amp;lt; 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;否则，x 将会向 y 发送一条好友请求。&lt;/p&gt;
&lt;p&gt;注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。&lt;/p&gt;
&lt;p&gt;返回在该社交媒体网站上产生的好友请求总数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1609-奇偶树</title>
      <link>/posts/1c05b892/</link>
      <pubDate>Sat, 25 Dec 2021 19:47:39 +0000</pubDate>
      
      <guid>/posts/1c05b892/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：&lt;/p&gt;
&lt;p&gt;二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-1705-吃苹果的最大数目</title>
      <link>/posts/48cf338b/</link>
      <pubDate>Fri, 24 Dec 2021 11:07:03 +0000</pubDate>
      
      <guid>/posts/48cf338b/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。&lt;/p&gt;
&lt;p&gt;你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。&lt;/p&gt;
&lt;p&gt;给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-686-重复叠加字符串匹配</title>
      <link>/posts/cb644e85/</link>
      <pubDate>Wed, 22 Dec 2021 09:21:49 +0000</pubDate>
      
      <guid>/posts/cb644e85/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&lt;/p&gt;
&lt;p&gt;注意：字符串 &amp;ldquo;abc&amp;rdquo; 重复叠加 0 次是 &amp;ldquo;&amp;quot;，重复叠加 1 次是 &amp;ldquo;abc&amp;rdquo;，重复叠加 2 次是 &amp;ldquo;abcabc&amp;rdquo;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-475-供暖器</title>
      <link>/posts/e63dcfe3/</link>
      <pubDate>Mon, 20 Dec 2021 09:31:58 +0000</pubDate>
      
      <guid>/posts/e63dcfe3/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。&lt;/p&gt;
&lt;p&gt;在加热器的加热半径范围内的每个房屋都可以获得供暖。&lt;/p&gt;
&lt;p&gt;现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。&lt;/p&gt;
&lt;p&gt;说明：所有供暖器都遵循你的半径标准，加热的半径也一样。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-419-甲板上的战舰</title>
      <link>/posts/aa19f9bb/</link>
      <pubDate>Sat, 18 Dec 2021 15:48:25 +0000</pubDate>
      
      <guid>/posts/aa19f9bb/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 &amp;lsquo;X&amp;rsquo; 或者是一个空位 &amp;lsquo;.&amp;rsquo; ，返回在甲板 board 上放置的 战舰 的数量。&lt;/p&gt;
&lt;p&gt;战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-851-喧闹和富有</title>
      <link>/posts/3f29dc95/</link>
      <pubDate>Wed, 15 Dec 2021 20:53:25 +0000</pubDate>
      
      <guid>/posts/3f29dc95/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。&lt;/p&gt;
&lt;p&gt;给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。&lt;/p&gt;
&lt;p&gt;现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-807-保持城市天际线</title>
      <link>/posts/9457eaea/</link>
      <pubDate>Mon, 13 Dec 2021 17:59:13 +0000</pubDate>
      
      <guid>/posts/9457eaea/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。&lt;/p&gt;
&lt;p&gt;城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。&lt;/p&gt;
&lt;p&gt;我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。&lt;/p&gt;
&lt;p&gt;在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode-911-在线选举</title>
      <link>/posts/acd85fa1/</link>
      <pubDate>Sat, 11 Dec 2021 16:56:15 +0000</pubDate>
      
      <guid>/posts/acd85fa1/</guid>
      <description>&lt;h3 id=&#34;题目&#34;&gt;题目&lt;a class=&#34;anchor ms-1&#34; href=&#34;#题目&#34;&gt;&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。&lt;/p&gt;
&lt;p&gt;对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。&lt;/p&gt;
&lt;p&gt;在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。&lt;/p&gt;
&lt;p&gt;实现 TopVotedCandidate 类：&lt;/p&gt;
&lt;p&gt;TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
