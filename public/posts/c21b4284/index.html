<!doctype html><html class="position-relative" itemscope itemtype="http://schema.org/WebPage" lang="zh-cn"
  
   data-palette="blue"
  >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Golang中GC回收机制三色标记与混合写屏障 - 编程日记</title><link rel="apple-touch-icon" href="/images/icons/icon-180x180.png" sizes="180x180">
<link rel="icon" href="/images/icons/icon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="/images/icons/icon-16x16.png" sizes="16x16" type="image/png">
<link rel="icon" href="/images/icons/favicon.ico">
<link rel="manifest" href="/manifest.json">
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<meta name="keywords" content="" />
<meta name="description" content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点" /><meta name="robots" content="index, follow" /><meta itemprop="name" content="Golang中GC回收机制三色标记与混合写屏障">
<meta itemprop="description" content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点"><meta itemprop="datePublished" content="2022-01-17T20:46:07+00:00" />
<meta itemprop="dateModified" content="2022-01-17T20:46:07+00:00" />
<meta itemprop="wordCount" content="5685">
<meta itemprop="keywords" content="教程,垃圾回收机制,混合写屏障,三色标记," /><meta property="og:title" content="Golang中GC回收机制三色标记与混合写屏障" />
<meta property="og:description" content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c21b4284/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-17T20:46:07+00:00" />
<meta property="article:modified_time" content="2022-01-17T20:46:07+00:00" /><meta property="og:site_name" content="编程日记" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang中GC回收机制三色标记与混合写屏障"/>
<meta name="twitter:description" content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点"/>
<meta property="og:image" content="/images/spider-man.jpg"/>
  <meta name="twitter:image" content="/images/spider-man.jpg"/><link rel="stylesheet" href="/assets/main/bundle.min.d09b7f7f687cbba5a0470808fba7973668726b909146fb392a44aa897b257a10.css" integrity="sha256-0Jt/f2h8u6WgRwgI+6eXNmhya5CRRvs5KkSqiXslehA=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/viewer/bundle.min.f05183267bb952fbc8c63a7178364de2951614ab71d544ec1068ad36c7447ccc.css" integrity="sha256-8FGDJnu5UvvIxjpxeDZN4pUWFKtx1UTsEGitNsdEfMw=" crossorigin="anonymous"></head>
  <body><script>const items=['mode','palette'];items.forEach(function(e){const t=localStorage.getItem('hbs-'+e);t&&document.body.parentElement.setAttribute('data-'+e,t)})</script><header><nav class="navbar top-app-bar top-app-bar-expand-lg fixed-top">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button><a class="navbar-brand flex-grow-1 flex-lg-grow-0 text-center text-lg-start mx-auto me-lg-3" href="/"><picture><img class="logo" alt="Logo" src="/images/spider-man.jpg" loading="lazy"
     width="556" height="559"
     />
</picture>
编程日记
    </a>
    <div class="offcanvas offcanvas-bottom surface" tabindex="-1" id="offcanvasSocialShare" aria-labelledby="offcanvasSocialShare">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">Share</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body">
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Twitter Share Button"
      target="_blank" href="https://twitter.com/intent/tweet?title=Golang%e4%b8%adGC%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e4%b8%8e%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c&url=%2fposts%2fc21b4284%2f">
      <i class="fab fa-fw fa-twitter"></i> Twitter
    </a>
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Facebook Share Button"
      target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=%2fposts%2fc21b4284%2f">
      <i class="fab fa-fw fa-facebook-f"></i> Facebook
    </a>
  </div>
</div>
    <button class="navbar-settings" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSettings"
  aria-controls="offcanvasSettings" aria-label="Toggle settings">
  <i class="fas fa-ellipsis-v"></i>
</button>

<div class="offcanvas offcanvas-end surface h-100" tabindex="-1" id="offcanvasSettings" aria-labelledby="offcanvasSettings">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">设置</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body d-flex flex-column">

<div class="setting">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-adjust"></i> 模式</label>
    </div>
    <div class="col-auto ms-auto">
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="modeSwitcher">
      </div>
    </div>
  </form>
</div>

<div class="setting">
  <form class="font-size-switcher-form row">
    <div class="col-auto">
      <label for="fontSize" class="form-label"><i class="fas fa-fw fa-font"></i> 字体大小</label>
    </div>
    <div class="col-auto ms-auto">
      <input type="range" class="form-range" min="-2" max="2" id="fontSize">
    </div>
  </form>
</div>


<div class="setting palettes">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-palette"></i> 配色</label>
    </div>
    <div class="col-auto ms-auto">
      <a id="btnPalette" class="btn btn-sm btn-outline-primary" role="button" aria-label="palettePicker">
        <i class="fas fa-eye-dropper"></i>
      </a>
    </div>
  </form>
  <div class="mt-2 d-flex justify-content-between visually-hidden" id="palettePicker"><button type="button" id="palette-blue" aria-label="蓝色"
        class="btn btn-sm w-100 palette" data-palette="blue">
      </button><button type="button" id="palette-blue-gray" aria-label="蓝灰色"
        class="btn btn-sm w-100 palette" data-palette="blue-gray">
      </button><button type="button" id="palette-brown" aria-label="棕色"
        class="btn btn-sm w-100 palette" data-palette="brown">
      </button><button type="button" id="palette-cyan" aria-label="青色"
        class="btn btn-sm w-100 palette" data-palette="cyan">
      </button><button type="button" id="palette-green" aria-label="绿色"
        class="btn btn-sm w-100 palette" data-palette="green">
      </button><button type="button" id="palette-indigo" aria-label="靛青色"
        class="btn btn-sm w-100 palette" data-palette="indigo">
      </button><button type="button" id="palette-orange" aria-label="橙色"
        class="btn btn-sm w-100 palette" data-palette="orange">
      </button><button type="button" id="palette-pink" aria-label="粉色"
        class="btn btn-sm w-100 palette" data-palette="pink">
      </button><button type="button" id="palette-purple" aria-label="紫色"
        class="btn btn-sm w-100 palette" data-palette="purple">
      </button><button type="button" id="palette-red" aria-label="红色"
        class="btn btn-sm w-100 palette" data-palette="red">
      </button><button type="button" id="palette-teal" aria-label="蓝绿色"
        class="btn btn-sm w-100 palette" data-palette="teal">
      </button><button type="button" id="palette-yellow" aria-label="黄色"
        class="btn btn-sm w-100 palette" data-palette="yellow">
      </button></div>
</div>
<div class="setting actions d-flex justify-content-around mt-auto overflow-auto">
  <a role="button" class="action action-go-back" href="javascript: window.history.back();">
    <span class="action-icon"><i class="fas fa-2x fa-chevron-circle-down" data-fa-transform="rotate-90"></i></span> 返回
  </a>
  <a role="button" class="action action-reload-page">
    <span class="action-icon"><i class="fas fa-2x fa-redo-alt"></i></span> 刷新
  </a>
  <a role="button" class="action action-copy-url">
    <span class="action-icon"><i class="fas fa-2x fa-link"></i></span> 复制链接
  </a><a class="action action-social-share" role="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSocialShare"
    aria-controls="offcanvasSocialShare" aria-label="Toggle social share">
    <span class="action-icon"><i class="fas fa-2x fa-share-alt"></i></span> 分享
  </a></div>

</div>
</div>

    <div class="collapse navbar-collapse" tabindex="-1" id="navbarSupportedContent" aria-labelledby="navbarSupportedContent">
      <form class="search-bar my-1" action="/search">
  <div class="input-group input-group-sm">
    <span class="btn btn-search disabled position-absolute left-0"><i class="fas fa-fw fa-search"></i></span>
    <input class="form-control rounded-pill" name="q" type="search" aria-label="Search">
  </div>
</form>
      <ul class="navbar-nav ms-auto"><li class="nav-item">
          <a class="nav-link" href="/series/">
            <i class="fas fa-fw fa-columns"></i>专栏
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="/archives/">
            <i class="fas fa-fw fa-file-archive"></i>归档
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="/categories/">
            <i class="fas fa-fw fa-folder"></i>分类
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="/tags/">
            <i class="fas fa-fw fa-tags"></i>标签
          </a>
        </li><li class="nav-item dropdown">
          <a class="nav-link" id="navbarDropdownFriends" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="fas fa-fw fa-chevron-circle-down"></i>友情链接
          </a>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdownFriends"><li>
              <a class="dropdown-item"
                href="https://xieash.work/" target="_blank" rel="noopener noreferrer">
                xieash
              </a>
            </li><li>
              <a class="dropdown-item"
                href="https://sunnysab.cn/" target="_blank" rel="noopener noreferrer">
                sunnysab
              </a>
            </li><li>
              <a class="dropdown-item"
                href="https://wanfengcxz.cn/" target="_blank" rel="noopener noreferrer">
                wanfengcxz
              </a>
            </li><li>
              <a class="dropdown-item"
                href="https://zhangzqs.cn/" target="_blank" rel="noopener noreferrer">
                zhangzqs
              </a>
            </li></ul>
        </li><li class="nav-item">
          <a class="nav-link" href="/data">
            资料
          </a>
        </li></ul>
    </div>
  </div>
</nav>
</header>
<main class="container">
      <div class="row content">
<div class="col-lg-8">
  <div class="container"><nav class="row card component" aria-label="breadcrumb">
  <div class="card-body">
    <ol class="breadcrumb "><li class="breadcrumb-item"><a href="/">主页</a></li><li class="breadcrumb-item"><a href="/posts/">Posts</a></li><li class="breadcrumb-item active">Golang中GC回收机制三色标记与混合写屏障</li></ol>
  </div>
</nav><div class="post-panel-wrapper position-sticky">
  <div class="d-flex flex-column component rounded post-panel position-absolute">
    
    <a class="action action-panel-toggler" role="button" title="Panel toggler">
      <i class="fas fa-fw fa-chevron-circle-down"></i>
    </a>
    <a id="sidebarToggler" class="action d-none d-lg-block" role="button" title="Sidebar toggler">
  <i class="fas fa-fw fa-expand-alt" data-fa-transform="rotate-45"></i>
</a>

    

    
    <a class="action" href="#post-copyright" role="button" aria-label="Copyright" title="Copyright">
  <i class="fas fa-fw fa-copyright"></i>
</a>
    
    <a class="action" href="#postTOC" aria-controls="Table of contents" role="button" title="Table of contents">
  <i class="fas fa-fw fa-list-alt"></i>
</a>
    
  </div>
</div>
<article class="row card component mb-4 post">
  <div class="card-header ">
    <h1 class="card-title post-title">Golang中GC回收机制三色标记与混合写屏障
</h1>
  </div>
  <div class="card-body"><div class="post-meta">
  <span class="post-date" title="创建于 2022-01-18 04:46:07 &#43;0800 CST。">
    2022-01-17
  </span><span class="post-reading-time">
    12 分钟阅读
  </span><span class="post-taxonomies"><a href="/tags/%E6%95%99%E7%A8%8B/" class="badge post-taxonomy">教程</a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="badge post-taxonomy">垃圾回收机制</a><a href="/tags/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C/" class="badge post-taxonomy">混合写屏障</a><a href="/tags/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/" class="badge post-taxonomy">三色标记</a></span>
</div>
<div class="post-content mb-3"><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p>
<p>Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点</p>
<ul>
<li>Go V1.5的三色并发标记法</li>
<li>Go V1.5的三色标记为什么需要STW</li>
<li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li>
<li>Go V1.8混合写屏障机制</li>
<li>Go V1.8混合写屏障机制的全场景分析</li>
</ul>
<h2 id="go-v13之前的标记-清除mark-and-sweep算法">Go V1.3之前的标记-清除(mark and sweep)算法<a class="anchor ms-1" href="#go-v13之前的标记-清除mark-and-sweep算法"><i class="fas fa-link"></i></a></h2>
<p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<h3 id="标记清除算法的具体步骤">标记清除算法的具体步骤<a class="anchor ms-1" href="#标记清除算法的具体步骤"><i class="fas fa-link"></i></a></h3>
<ol>
<li>
<p>暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p>
<p><picture><img class="img-fluid" alt="image-20220117210535275" src="/posts/c21b4284/index/image-20220117210535275.png" loading="lazy"
    
     />
</picture>

</p>
<p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p>
</li>
<li>
<p>开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<p><picture><img class="img-fluid" alt="image-20220117210645781" src="/posts/c21b4284/index/image-20220117210645781.png" loading="lazy"
    
     />
</picture>

</p>
<p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p>
</li>
<li>
<p>标记完了之后，然后开始清除未标记的对象. 结果如下。</p>
<p><picture><img class="img-fluid" alt="image-20220117210728045" src="/posts/c21b4284/index/image-20220117210728045.png" loading="lazy"
    
     />
</picture>

</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p>
</li>
<li>
<p>停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
</li>
</ol>
<p>以上便是标记-清除（mark and sweep）回收的算法。</p>
<h3 id="标记-清除mark-and-sweep的缺点">标记-清除(mark and sweep)的缺点<a class="anchor ms-1" href="#标记-清除mark-and-sweep的缺点"><i class="fas fa-link"></i></a></h3>
<p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p>
<ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 <strong>(重要问题)</strong>；</li>
<li>标记需要扫描整个heap；</li>
<li>清除数据会产生heap碎片。</li>
</ul>
<p>Go V1.3版本之前就是以上来实施的, 在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117211240034" src="/posts/c21b4284/index/image-20220117211240034.png" loading="lazy"
    
     />
</picture>

</p>
<p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p>
<p><picture><img class="img-fluid" alt="image-20220117211306851" src="/posts/c21b4284/index/image-20220117211306851.png" loading="lazy"
    
     />
</picture>

</p>
<p>上图主要是将STW的步骤提前了异步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p>
<p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是<strong>mark-and-sweep 算法会暂停整个程序</strong> 。</p>
<p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题.</p>
<h2 id="go-v15的三色并发标记法">Go V1.5的三色并发标记法<a class="anchor ms-1" href="#go-v15的三色并发标记法"><i class="fas fa-link"></i></a></h2>
<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的<strong>STW(stop the world)</strong>，所谓<strong>三色标记法</strong>实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p>
<ol>
<li>
<p>每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212242391" src="/posts/c21b4284/index/image-20220117212242391.png" loading="lazy"
    
     />
</picture>

</p>
<p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的跟节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212341484" src="/posts/c21b4284/index/image-20220117212341484.png" loading="lazy"
    
     />
</picture>

</p>
</li>
<li>
<p>每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212436917" src="/posts/c21b4284/index/image-20220117212436917.png" loading="lazy"
    
     />
</picture>

</p>
<p>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p>
</li>
<li>
<p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212542924" src="/posts/c21b4284/index/image-20220117212542924.png" loading="lazy"
    
     />
</picture>

</p>
<p>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p>
</li>
<li>
<p>重复<strong>第三步</strong>, 直到灰色中无任何对象，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212625146" src="/posts/c21b4284/index/image-20220117212625146.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220117212646795" src="/posts/c21b4284/index/image-20220117212646795.png" loading="lazy"
    
     />
</picture>

</p>
<p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p>
</li>
<li>
<p>回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117212728177" src="/posts/c21b4284/index/image-20220117212728177.png" loading="lazy"
    
     />
</picture>

</p>
<p>以上我们将全部的白色对象进行删除回收，剩下的就是全部依赖的黑色对象。</p>
<p>以上便是<code>三色并发标记法</code>，不难看出，我们上面已经清楚的体现<code>三色</code>的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</p>
<p>那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
</li>
</ol>
<h2 id="没有stw的三色标记法">没有STW的三色标记法<a class="anchor ms-1" href="#没有stw的三色标记法"><i class="fas fa-link"></i></a></h2>
<p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？
我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117223500168" src="/posts/c21b4284/index/image-20220117223500168.png" loading="lazy"
    
     />
</picture>

</p>
<p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p>
<p><picture><img class="img-fluid" alt="image-20220117223523326" src="/posts/c21b4284/index/image-20220117223523326.png" loading="lazy"
    
     />
</picture>

</p>
<p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117223552188" src="/posts/c21b4284/index/image-20220117223552188.png" loading="lazy"
    
     />
</picture>

</p>
<p>然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117223619798" src="/posts/c21b4284/index/image-20220117223619798.png" loading="lazy"
    
     />
</picture>

</p>
<p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p>
<p><picture><img class="img-fluid" alt="image-20220117223705060" src="/posts/c21b4284/index/image-20220117223705060.png" loading="lazy"
    
     />
</picture>

</p>
<p>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p>
<p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p>
<ul>
<li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li>
<li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**
如果当以上两个条件同时满足时，就会出现对象丢失现象!</li>
</ul>
<p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p>
<h2 id="屏障机制">屏障机制<a class="anchor ms-1" href="#屏障机制"><i class="fas fa-link"></i></a></h2>
<p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。 这两种方式就是“强三色不变式”和“弱三色不变式”。</p>
<h3 id="强弱三色不变式">强弱三色不变式<a class="anchor ms-1" href="#强弱三色不变式"><i class="fas fa-link"></i></a></h3>
<h4 id="强三色不变式">强三色不变式<a class="anchor ms-1" href="#强三色不变式"><i class="fas fa-link"></i></a></h4>
<p>不存在黑色对象引用到白色对象的指针。破坏条件1</p>
<p><picture><img class="img-fluid" alt="image-20220117232344555" src="/posts/c21b4284/index/image-20220117232344555.png" loading="lazy"
    
     />
</picture>

</p>
<p>弱三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p>
<h4 id="弱三色不变式">弱三色不变式<a class="anchor ms-1" href="#弱三色不变式"><i class="fas fa-link"></i></a></h4>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态。破坏条件2</p>
<p><picture><img class="img-fluid" alt="image-20220117232437203" src="/posts/c21b4284/index/image-20220117232437203.png" loading="lazy"
    
     />
</picture>

</p>
<p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p>
<p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p>
<h3 id="插入屏障">插入屏障<a class="anchor ms-1" href="#插入屏障"><i class="fas fa-link"></i></a></h3>
<p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<p>伪码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">添加下游对象</span><span class="p">(</span><span class="nx">当前下游对象slot</span><span class="p">,</span> <span class="nx">新下游对象ptr</span><span class="p">)</span> <span class="p">{</span>   
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="c1">//1
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>  <span class="nx">标记灰色</span><span class="p">(</span><span class="nx">新下游对象ptr</span><span class="p">)</span>   
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="c1">//2
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>  <span class="nx">当前下游对象slot</span> <span class="p">=</span> <span class="nx">新下游对象ptr</span>  				  
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>场景：</p>
<blockquote>
<p>A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</p>
</blockquote>
<p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><picture><img class="img-fluid" alt="image-20220118110847719" src="/posts/c21b4284/index/image-20220118110847719.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118110907807" src="/posts/c21b4284/index/image-20220118110907807.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118110927155" src="/posts/c21b4284/index/image-20220118110927155.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118110946799" src="/posts/c21b4284/index/image-20220118110946799.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111009046" src="/posts/c21b4284/index/image-20220118111009046.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111052664" src="/posts/c21b4284/index/image-20220118111052664.png" loading="lazy"
    
     />
</picture>

</p>
<p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<p><picture><img class="img-fluid" alt="image-20220118111111574" src="/posts/c21b4284/index/image-20220118111111574.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111129525" src="/posts/c21b4284/index/image-20220118111129525.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111148821" src="/posts/c21b4284/index/image-20220118111148821.png" loading="lazy"
    
     />
</picture>

</p>
<p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p>
<p><picture><img class="img-fluid" alt="image-20220118111206635" src="/posts/c21b4284/index/image-20220118111206635.png" loading="lazy"
    
     />
</picture>

</p>
<h3 id="删除屏障">删除屏障<a class="anchor ms-1" href="#删除屏障"><i class="fas fa-link"></i></a></h3>
<p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p>
<p>伪代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">添加下游对象</span><span class="p">(</span><span class="nx">当前下游对象slot</span><span class="err">，</span> <span class="nx">新下游对象ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="c1">//1
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">当前下游对象slot是灰色</span> <span class="o">||</span> <span class="nx">当前下游对象slot是白色</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  		<span class="nx">标记灰色</span><span class="p">(</span><span class="nx">当前下游对象slot</span><span class="p">)</span>     <span class="c1">//slot为被删除对象， 标记为灰色
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="c1">//2
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span>  <span class="nx">当前下游对象slot</span> <span class="p">=</span> <span class="nx">新下游对象ptr</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>场景：</p>
<blockquote>
<p>A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)		 //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</p>
</blockquote>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><picture><img class="img-fluid" alt="image-20220118111225425" src="/posts/c21b4284/index/image-20220118111225425.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111240242" src="/posts/c21b4284/index/image-20220118111240242.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111304756" src="/posts/c21b4284/index/image-20220118111304756.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111324015" src="/posts/c21b4284/index/image-20220118111324015.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111341188" src="/posts/c21b4284/index/image-20220118111341188.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111356369" src="/posts/c21b4284/index/image-20220118111356369.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111413768" src="/posts/c21b4284/index/image-20220118111413768.png" loading="lazy"
    
     />
</picture>

</p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="go-v18的混合写屏障hybrid-write-barrier机制">Go V1.8的混合写屏障(hybrid write barrier)机制<a class="anchor ms-1" href="#go-v18的混合写屏障hybrid-write-barrier机制"><i class="fas fa-link"></i></a></h2>
<p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li>
</ul>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<h3 id="混合写屏障规则">混合写屏障规则<a class="anchor ms-1" href="#混合写屏障规则"><i class="fas fa-link"></i></a></h3>
<p><code>具体操作</code>:</p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被<strong>删除</strong>的对象标记为灰色。</p>
<p>4、被<strong>添加</strong>的对象标记为灰色。</p>
<p><code>满足</code>: 变形的<strong>弱三色不变式</strong>（结合了插入、删除写屏障两者的优点）</p>
<p>伪代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nx">添加下游对象</span><span class="p">(</span><span class="nx">当前下游对象slot</span><span class="p">,</span> <span class="nx">新下游对象ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  	<span class="c1">//1 
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>	<span class="nx">标记灰色</span><span class="p">(</span><span class="nx">当前下游对象slot</span><span class="p">)</span>    <span class="c1">//只要当前下游对象被移走，就标记灰色
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  	
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  	<span class="c1">//2 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>  	<span class="nx">标记灰色</span><span class="p">(</span><span class="nx">新下游对象ptr</span><span class="p">)</span>		<span class="c1">// 强三色
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>  		
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  	<span class="c1">//3
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>  	<span class="nx">当前下游对象slot</span> <span class="p">=</span> <span class="nx">新下游对象ptr</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
</blockquote>
<h3 id="混合写屏障的具体场景分析">混合写屏障的具体场景分析<a class="anchor ms-1" href="#混合写屏障的具体场景分析"><i class="fas fa-link"></i></a></h3>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<blockquote>
<p>注意混合写屏障是GC的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
</blockquote>
<p>GC开始：扫描栈区，将可达对象全部标记为黑</p>
<p><picture><img class="img-fluid" alt="image-20220118111706579" src="/posts/c21b4284/index/image-20220118111706579.png" loading="lazy"
    
     />
</picture>

</p>
<p>栈上的全部标记为黑，就不会再次扫描了</p>
<p><picture><img class="img-fluid" alt="image-20220118111721295" src="/posts/c21b4284/index/image-20220118111721295.png" loading="lazy"
    
     />
</picture>

</p>
<h4 id="场景一-对象被一个堆对象删除引用成为栈对象的下游">场景一： 对象被一个堆对象删除引用，成为栈对象的下游<a class="anchor ms-1" href="#场景一-对象被一个堆对象删除引用成为栈对象的下游"><i class="fas fa-link"></i></a></h4>
<h5 id="伪代码">伪代码<a class="anchor ms-1" href="#伪代码"><i class="fas fa-link"></i></a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="nx">栈对象1</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">堆对象7</span><span class="err">；</span>  <span class="c1">//将堆对象7 挂在 栈对象1 下游
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="nx">堆对象4</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">null</span><span class="err">；</span>    <span class="c1">//对象4 删除引用 对象7
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// 代码解释
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="nx">heap4</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">obj7</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="nx">stack1</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">heap7</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="nx">heap4</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span></code></pre></div><p><picture><img class="img-fluid" alt="image-20220118111809785" src="/posts/c21b4284/index/image-20220118111809785.png" loading="lazy"
    
     />
</picture>

</p>
<p>对象4删除对象7的引用关系</p>
<p>对象7要被删除，对象7被标记为灰色</p>
<p><picture><img class="img-fluid" alt="image-20220118111824561" src="/posts/c21b4284/index/image-20220118111824561.png" loading="lazy"
    
     />
</picture>

</p>
<p>对象4就删除了对象7的引用，</p>
<p>此时对象7变为灰色，下一轮将被扫描，被保护</p>
<h4 id="场景二-对象被一个栈对象删除引用成为另一个栈对象的下游">场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游<a class="anchor ms-1" href="#场景二-对象被一个栈对象删除引用成为另一个栈对象的下游"><i class="fas fa-link"></i></a></h4>
<h5 id="伪代码-1">伪代码<a class="anchor ms-1" href="#伪代码-1"><i class="fas fa-link"></i></a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">new</span> <span class="nx">栈对象9</span><span class="err">；</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nx">对象9</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象3</span> <span class="p">=</span> <span class="nx">对象3</span><span class="err">；</span>      <span class="c1">//将栈对象3 挂在 栈对象9 下游
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="nx">对象2</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象3</span> <span class="p">=</span> <span class="nx">null</span><span class="err">；</span>      <span class="c1">//对象2 删除引用 对象3
</span></span></span></code></pre></div><p><picture><img class="img-fluid" alt="image-20220118111917714" src="/posts/c21b4284/index/image-20220118111917714.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111932094" src="/posts/c21b4284/index/image-20220118111932094.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118111944954" src="/posts/c21b4284/index/image-20220118111944954.png" loading="lazy"
    
     />
</picture>

</p>
<h4 id="场景三对象被一个堆对象删除引用成为另一个堆对象的下游">场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游<a class="anchor ms-1" href="#场景三对象被一个堆对象删除引用成为另一个堆对象的下游"><i class="fas fa-link"></i></a></h4>
<h5 id="伪代码-2">伪代码<a class="anchor ms-1" href="#伪代码-2"><i class="fas fa-link"></i></a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">堆对象10</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">堆对象7</span><span class="err">；</span>       <span class="c1">//将堆对象7 挂在 堆对象10 下游
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="nx">堆对象4</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">null</span><span class="err">；</span>         <span class="c1">//对象4 删除引用 对象7
</span></span></span></code></pre></div><p><picture><img class="img-fluid" alt="image-20220118112023455" src="/posts/c21b4284/index/image-20220118112023455.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118112037632" src="/posts/c21b4284/index/image-20220118112037632.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118112052003" src="/posts/c21b4284/index/image-20220118112052003.png" loading="lazy"
    
     />
</picture>

</p>
<h4 id="场景四对象从一个栈对象删除引用成为另一个堆对象的下游">场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游<a class="anchor ms-1" href="#场景四对象从一个栈对象删除引用成为另一个堆对象的下游"><i class="fas fa-link"></i></a></h4>
<h5 id="伪代码-3">伪代码<a class="anchor ms-1" href="#伪代码-3"><i class="fas fa-link"></i></a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln">1</span><span class="cl"><span class="nx">堆对象10</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">堆对象7</span><span class="err">；</span>       <span class="c1">//将堆对象7 挂在 堆对象10 下游
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="nx">堆对象4</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">对象7</span> <span class="p">=</span> <span class="nx">null</span><span class="err">；</span>         <span class="c1">//对象4 删除引用 对象7
</span></span></span></code></pre></div><p><picture><img class="img-fluid" alt="image-20220118112132700" src="/posts/c21b4284/index/image-20220118112132700.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118112150923" src="/posts/c21b4284/index/image-20220118112150923.png" loading="lazy"
    
     />
</picture>

</p>
<p><picture><img class="img-fluid" alt="image-20220118112209127" src="/posts/c21b4284/index/image-20220118112209127.png" loading="lazy"
    
     />
</picture>

</p>
<p>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p>
<h2 id="参考">参考<a class="anchor ms-1" href="#参考"><i class="fas fa-link"></i></a></h2>
<p><a href="https://www.bilibili.com/video/BV1wz4y1y7Kd?p=9" target="_blank" rel="noopener noreferrer">Golang中GC回收机制三色标记与混合写屏障_哔哩哔哩_bilibili</a></p></div></div>
  <div class="card-footer"><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev">
    <i class="fas fa-fw fa-chevron-circle-down post-prev-icon" data-fa-transform="rotate-90"></i>
    <a href="/posts/cb818503/">Go调度器GMP调度场景
</a>
  </div><div class="post-nav post-next">
    <a href="/posts/427ffcfc/">Golang逃逸现象
</a>
    <i class="fas fa-fw fa-chevron-circle-down post-next-icon" data-fa-transform="rotate-270"></i>
  </div></div></div>
</article><div class="post-copyright mb-3 row card component" id="post-copyright">
    <div class="card-header">
        <h2 class="card-title">版权</h2>
    </div>
    <div class="card-body"><a class="d-flex align-items-center flex-column" target="_blank" rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">
  <span><i class="fab fa-fw fa-2x fa-creative-commons"></i><i class="fab fa-fw fa-2x fa-creative-commons-by"></i><i class="fab fa-fw fa-2x fa-creative-commons-nc"></i><i class="fab fa-fw fa-2x fa-creative-commons-nd"></i></span>
  CC BY-NC-ND 4.0 
</a>


    </div>
</div><section class="related-posts row card component">
    <div class="card-header">
      <h2 class="card-title">相关文章</h2>
    </div>
    <div class="card-body">
      <ul class="post-list"><li>
          <a href="/posts/cb818503/">Go调度器GMP调度场景
</a>
          <span class="float-end post-date">2022-01-17
</span>
        </li><li>
          <a href="/posts/c56e43df/">在Linux安装Go环境
</a>
          <span class="float-end post-date">2022-01-17
</span>
        </li><li>
          <a href="/posts/61098f97/">Goroutine调度器的GMP模型的设计思想
</a>
          <span class="float-end post-date">2022-01-17
</span>
        </li><li>
          <a href="/posts/46db0928/">Golang调度器的由来
</a>
          <span class="float-end post-date">2022-01-16
</span>
        </li><li>
          <a href="/posts/e6a3ea27/">Docker部署Go项目
</a>
          <span class="float-end post-date">2022-01-10
</span>
        </li></ul>
    </div>
  </section></div>
</div><aside class="col-lg-4 sidebar d-flex">
  <div class="container d-flex flex-column">
    
    <div class="card row text-center profile component">
  <div class="card-body">
    <div class="col-12 d-flex align-items-center justify-content-center"><picture><img class="profile-avatar rounded-circle" alt="jimyag" src="/images/spider-man.jpg" loading="lazy" data-viewer-invisible
     width="556" height="559"
     />
</picture>
</div>
    <div class="col-12 profile-meta"><div class="profile-name">jimyag</div><div class="profile-bio">Gopher</div><div class="profile-location"><i class="fas fa-fw fa-map-marker-alt"></i>Shanghai</div><div class="profile-about"><i class="fas fa-fw fa-user"></i><a href="/about/">About</a></div><nav class="social-links nav justify-content-center"><a class="nav-link social-link" href="mailto:i@jimyag.cn" title="Email">
      <i class="fas fa-fw fa-2x fa-envelope"></i>
    </a><a class="nav-link social-link" target="_blank" href="https://github.com/jimyag" title="GitHub" rel="noopener noreferrer">
        <i class="fa-fw fa-2x fab fa-github"></i>
      </a><a class="nav-link social-link" target="_blank" href="/index.xml" title="RSS" rel="noopener noreferrer">
    <i class="fas fa-fw fa-2x fa-rss"></i>
  </a></nav>
</div>
  </div>
</div>
<div class="post-toc row mb-4 card component" id="postTOC">
  <div class="card-header">
    <h2 class="card-title">目录</h2>
  </div>
  <div class="card-body">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#go-v13之前的标记-清除mark-and-sweep算法">Go V1.3之前的标记-清除(mark and sweep)算法</a>
      <ul>
        <li><a href="#标记清除算法的具体步骤">标记清除算法的具体步骤</a></li>
        <li><a href="#标记-清除mark-and-sweep的缺点">标记-清除(mark and sweep)的缺点</a></li>
      </ul>
    </li>
    <li><a href="#go-v15的三色并发标记法">Go V1.5的三色并发标记法</a></li>
    <li><a href="#没有stw的三色标记法">没有STW的三色标记法</a></li>
    <li><a href="#屏障机制">屏障机制</a>
      <ul>
        <li><a href="#强弱三色不变式">强弱三色不变式</a></li>
        <li><a href="#插入屏障">插入屏障</a></li>
        <li><a href="#删除屏障">删除屏障</a></li>
      </ul>
    </li>
    <li><a href="#go-v18的混合写屏障hybrid-write-barrier机制">Go V1.8的混合写屏障(hybrid write barrier)机制</a>
      <ul>
        <li><a href="#混合写屏障规则">混合写屏障规则</a></li>
        <li><a href="#混合写屏障的具体场景分析">混合写屏障的具体场景分析</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div><section class="recent-posts row card component">
  <div class="card-header">
    <h2 class="card-title">最近文章</h2>
  </div>
  <div class="card-body">
    <ul class="post-list"><li>
        <a href="/posts/6db6b747/">Google MapReduce翻译
</a>
      </li><li>
        <a href="/posts/f6adfb46/">6.824 Spring 2020 Lab1 MapReduce文档翻译
</a>
      </li><li>
        <a href="/posts/14976c16/">我的notion规划
</a>
      </li><li>
        <a href="/posts/9c78a390/">Git开发分支落后远程主分支
</a>
      </li><li>
        <a href="/posts/0f0b28a1/">Oh My Zsh进入git目录卡顿
</a>
      </li></ul>
  </div>
</section><section class="series-taxonomies row card component">
      <div class="card-header">
        <h2 class="card-title">
          <a href="/series">专栏</a>
        </h2>
      </div>
      <div class="card-body">
        <div class="py-2"><a href="/series/leetcode/" class="badge rounded post-taxonomy" title="leetcode">
            leetcode<span class="badge badge-sm text-white bg-accent ms-1">32</span></a><a href="/series/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/" class="badge rounded post-taxonomy" title="从0到1实现完整的微服务框架">
            从0到1实现完整的微服务框架<span class="badge badge-sm text-white bg-accent ms-1">12</span></a><a href="/series/%E7%89%9B%E5%AE%A2top101/" class="badge rounded post-taxonomy" title="牛客TOP101">
            牛客TOP101<span class="badge badge-sm text-white bg-accent ms-1">3</span></a><a href="/series/mit6.824/" class="badge rounded post-taxonomy" title="MIT6.824">
            MIT6.824<span class="badge badge-sm text-white bg-accent ms-1">2</span></a><a href="/series/vim/" class="badge rounded post-taxonomy" title="vim">
            vim<span class="badge badge-sm text-white bg-accent ms-1">1</span></a></div>
      </div>
    </section><section class="categories-taxonomies row card component">
      <div class="card-header">
        <h2 class="card-title">
          <a href="/categories">分类</a>
        </h2>
      </div>
      <div class="card-body">
        <div class="py-2"><a href="/categories/leetcode/" class="badge rounded post-taxonomy" title="LeetCode">
            LeetCode<span class="badge badge-sm text-white bg-accent ms-1">32</span></a><a href="/categories/%E6%95%99%E7%A8%8B/" class="badge rounded post-taxonomy" title="教程">
            教程<span class="badge badge-sm text-white bg-accent ms-1">9</span></a><a href="/categories/go/" class="badge rounded post-taxonomy" title="Go">
            Go<span class="badge badge-sm text-white bg-accent ms-1">4</span></a><a href="/categories/%E7%AE%97%E6%B3%95/" class="badge rounded post-taxonomy" title="算法">
            算法<span class="badge badge-sm text-white bg-accent ms-1">4</span></a><a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="badge rounded post-taxonomy" title="编译原理">
            编译原理<span class="badge badge-sm text-white bg-accent ms-1">3</span></a><a href="/categories/%E8%B8%A9%E5%9D%91/" class="badge rounded post-taxonomy" title="踩坑">
            踩坑<span class="badge badge-sm text-white bg-accent ms-1">3</span></a><a href="/categories/hexo/" class="badge rounded post-taxonomy" title="Hexo">
            Hexo<span class="badge badge-sm text-white bg-accent ms-1">2</span></a><a href="/categories/web/" class="badge rounded post-taxonomy" title="Web">
            Web<span class="badge badge-sm text-white bg-accent ms-1">2</span></a><a href="/categories/yolov5/" class="badge rounded post-taxonomy" title="YOLOV5">
            YOLOV5<span class="badge badge-sm text-white bg-accent ms-1">2</span></a><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="badge rounded post-taxonomy" title="计算机网络">
            计算机网络<span class="badge badge-sm text-white bg-accent ms-1">2</span></a><a href="/categories" class="badge rounded post-taxonomy" title='全部'>
          全部
          <span class="badge badge-sm text-white bg-accent ms-1">22</span>
        </a></div>
      </div>
    </section><section class="tags-taxonomies row card component">
      <div class="card-header">
        <h2 class="card-title">
          <a href="/tags">标签</a>
        </h2>
      </div>
      <div class="card-body">
        <div class="py-2"><a href="/tags/%E6%95%99%E7%A8%8B/" class="badge rounded post-taxonomy" title="教程">
            教程<span class="badge badge-sm text-white bg-accent ms-1">29</span></a><a href="/tags/%E4%B8%AD%E7%AD%89/" class="badge rounded post-taxonomy" title="中等">
            中等<span class="badge badge-sm text-white bg-accent ms-1">14</span></a><a href="/tags/%E7%AE%80%E5%8D%95/" class="badge rounded post-taxonomy" title="简单">
            简单<span class="badge badge-sm text-white bg-accent ms-1">13</span></a><a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="badge rounded post-taxonomy" title="微服务">
            微服务<span class="badge badge-sm text-white bg-accent ms-1">12</span></a><a href="/tags/grpc/" class="badge rounded post-taxonomy" title="gRPC">
            gRPC<span class="badge badge-sm text-white bg-accent ms-1">10</span></a><a href="/tags/go/" class="badge rounded post-taxonomy" title="Go">
            Go<span class="badge badge-sm text-white bg-accent ms-1">9</span></a><a href="/tags/%E6%A8%A1%E6%8B%9F/" class="badge rounded post-taxonomy" title="模拟">
            模拟<span class="badge badge-sm text-white bg-accent ms-1">7</span></a><a href="/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" class="badge rounded post-taxonomy" title="复习资料">
            复习资料<span class="badge badge-sm text-white bg-accent ms-1">6</span></a><a href="/tags/%E5%9B%B0%E9%9A%BE/" class="badge rounded post-taxonomy" title="困难">
            困难<span class="badge badge-sm text-white bg-accent ms-1">5</span></a><a href="/tags/%E7%AE%97%E6%B3%95/" class="badge rounded post-taxonomy" title="算法">
            算法<span class="badge badge-sm text-white bg-accent ms-1">5</span></a><a href="/tags" class="badge rounded post-taxonomy" title='全部'>
          全部
          <span class="badge badge-sm text-white bg-accent ms-1">81</span>
        </a></div>
      </div>
    </section>
    
  </div>
</aside>
</div>
    </main><footer class="footer mt-auto py-3 text-center container"><nav class="social-links nav justify-content-center mb-2"><a class="nav-link social-link" href="mailto:i@jimyag.cn" title="Email">
      <i class="fas fa-fw fa-2x fa-envelope"></i>
    </a><a class="nav-link social-link" target="_blank" href="https://github.com/jimyag" title="GitHub" rel="noopener noreferrer">
        <i class="fa-fw fa-2x fab fa-github"></i>
      </a><a class="nav-link social-link" target="_blank" href="/index.xml" title="RSS" rel="noopener noreferrer">
    <i class="fas fa-fw fa-2x fa-rss"></i>
  </a></nav>
<div class="copyright mb-2">
  Copyright © 2019-2022 jimyag. All Rights Reserved. 
</div>
<div class="powered-by mb-2">
  <a href="https://beian.miit.gov.cn" target="_blank" rel="noopener noreferrer">陕ICP备2020018182号-1 </a>
</div></footer>
<script src="/assets/main/bundle.min.b5532796c3cf4f82f5b0254d4790694b9a7766fb69b6fc6bd76c68a1946df067.js" integrity="sha256-tVMnlsPPT4L1sCVNR5BpS5p3Zvtptvxr12xooZRt8Gc=" crossorigin="anonymous" defer></script><script src="/assets/icons/bundle.min.dfcbe757302616d36e2f117823c56facf382204bf3ab9ea29dffd5f2fc56bdef.js" integrity="sha256-38vnVzAmFtNuLxF4I8VvrPOCIEvzq56inf/V8vxWve8=" crossorigin="anonymous" defer></script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('\/service-worker.min.js').then(function(reg) {
      console.log('Successfully registered service worker', reg);
    }).catch(function(err) {
      console.warn('Error whilst registering service worker', err);
    });
  });
}
</script><script src="/assets/viewer/bundle.min.0ec873e11f754ed0ad81a68dca8496e24286666354e9c7c11ff339c390f086f0.js" integrity="sha256-Dshz4R91TtCtgaaNyoSW4kKGZmNU6cfBH/M5w5DwhvA=" crossorigin="anonymous" defer></script>
</body>
</html>
